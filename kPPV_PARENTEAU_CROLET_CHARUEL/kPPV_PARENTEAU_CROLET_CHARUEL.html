<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <link rel="stylesheet" type="text/css" href="style.css">
    <link rel="icon" href="https://cdn.icon-icons.com/icons2/1352/PNG/512/if-06-harry-potter-colour-sorting-hat-2730319_88134.png">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/brython/3.11.2/brython.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/brython/3.11.2/brython_stdlib.min.js"></script>
    <title>Le Quizz du Choixpeau Magique !</title>
</head>

<body onload="brython()">
    <div>
        <div class="wave"></div>
        <div class="wave"></div>
        <div class="wave"></div>
    </div>
    <script type="text/python">
        # coding: utf-8
        '''
        Paul PARENTEAU-DENOEL
        Alexandre CROLET
        Arthur CHARUEL

        Programme permettant d'exécuter l'algorithme des plus proches voisins des personnages d'Harry Potter

        lien de la forge github : https://github.com/Achinappe/Choixpeau/tree/main
        Licence : CC-BY-HA
        Version : 1.12.1
        '''
        
        from math import sqrt
        from random import randint
        from browser import html, document, window
        import csv

        DICO_QUESTION = {1 : {"Question" : "Q1", "Reponses" : ("Oui", "Non", "Peut-être")}, 2 : {"Question" : "Q2", "Reponses" : ("Oui", "Non", "Peut-être")}, 3 : {"Question" : "Q3", "Reponses" : ("Oui", "Non", "Peut-être")}}
        #importation des personnages et des caractéristiques
        with open("Characters.csv", mode='r', encoding='utf-8') as f:
            reader = csv.DictReader(f, delimiter=';')
            characters_tab = [{key : value.replace('\xa0', ' ') for key, value in element.items()} for element in reader]


        with open("Caracteristiques_des_persos.csv", mode='r', encoding='utf-8') as f:
            reader = csv.DictReader(f, delimiter=';')
            characteristics_tab = [dico for dico in reader]
        
        #fusion de tables
        updated_characters_tab = []
        for kaggle_character in characters_tab:
            for poudlard_character in characteristics_tab:
                if poudlard_character['Name'] == kaggle_character['Name']:
                    kaggle_character.update(poudlard_character)
                    updated_characters_tab.append(kaggle_character)

        
        
        #définitions de fonctions
        def indexation(tab: list) -> dict:
            '''
            Indexe une table en Entrée
            Entrée : tab, table à indexer
            Sortie : index_id_characteristics, table indexée
            '''
            index_id_characteristics = {character['Id']:
                                         {'Name' : character['Name'],
                                          'House' : character['House'],
                                          'Courage' : int(character['Courage']),
                                          'Ambition' : int(character['Ambition']),
                                          'Intelligence' : int(character['Intelligence']),
                                          'Good' : int(character['Good'])}
                                         for character in tab}
            return index_id_characteristics

        def experimental_data_creation(support_tab: list) -> dict:
            '''
            Crée des données test à partir d'une table en Entrée
            Entrée : support_tab, table servant de support pour les données
            Sortie : test_characters, table indexée de personnages test, characters_copy, table indexée contenant les personnages restants
            '''
            test_characters = []
            characters_copy = support_tab[:]
            for _ in range(len(characters_copy) // 4):
                test_characters.append(characters_copy.pop(randint(0, len(characters_copy) - 1)))
            return indexation(test_characters), indexation(characters_copy)

        def distance(character1: dict, target_character: dict, methode='euclidienne') -> float:
            '''
            Calcule la distance entre deux personnages
            Entrée : character1, personnage test; target_character, personnage à tester
            Sortie : target_character, personnage à test_characters
            '''
            return ((character1['Courage'] - target_character['Courage']) ** 2
                            + (character1['Ambition'] - target_character['Ambition']) ** 2
                            + (character1['Intelligence'] - target_character['Intelligence']) ** 2
                            + (character1['Good'] - target_character['Good']) ** 2) ** 0.5

        def distance_addition(tab: dict, unknown_character: dict) -> list:
            '''
            Assemble toutes les distances calculées auparavant
            Entrée : tab, table de support; unknown_character, dictionnaire de personnage à tester 
            Sortie : distance_tab, table des distances avec les personnages
            '''
            distance_tab = []
            for character in tab.values():
                character['Distance'] = distance(unknown_character, character)
                distance_tab.append(character)
            return distance_tab

        def best_house(tab: dict) -> str:
            '''
            Détermine la maison la plus adaptée pour un profil à partir d'une table de distances
            Entrée : tab, table des distances 
            Sortie : top_house, meilleure maison
            '''
            houses = {}
            for neighbour in tab:
                if neighbour['House'] in houses:
                    houses[neighbour['House']] += 1
                else:
                    houses[neighbour['House']] = 1
            maximum = 0
            for house, nb in houses.items():
                if nb > maximum:
                    maximum = nb
                    top_house = house
            return top_house
        
        #définition de variables importantes
        indexed_characters_tab = indexation(updated_characters_tab)
        best_k = 0
        
        def validation_croisee(ev):
            '''
            Effectue la validation croisée
            Entrée : ev, évènement qui déclenche la fonction
            Sortie : None
            '''
            global best_k
            document["texte_validation1"].html = ""
            document["texte_validation2"].html = ""
            test_nb = int(input("Saisissez le nombre de test à effectuer pour chaque valeur de k. Une valeur élevée permet une meilleure précision mais a un coût en performances"))
            temp = 0

            #exécution des test
            for k in range(1, 11, 2):
                bingo = 0
                for test in range(test_nb):
                    test_characters, characters_remaining = experimental_data_creation(updated_characters_tab)
                    for target_character in test_characters.values():
                        characters_with_distances = distance_addition(characters_remaining, target_character)
                        neighbours = sorted(characters_with_distances, key=lambda x: x['Distance'])
                        if best_house(neighbours[:k]) == target_character['House']:
                            bingo += 1
                    if bingo > temp:
                        temp = bingo
                        best_k = k        
                #affichage
                document["texte_validation1"].html += f"- Pourcentage de réussite avec k = {k} : {round(bingo / len(test_characters.values()), 2)} %<br>"
            document["texte_validation2"].textContent = f"La meilleure valeur de k est : {best_k}"
        document["Validation croisée"].bind("click", validation_croisee)

        def profils_demandes(ev):
            '''
            Affiche les résultats pour les profils demandés 
            Entrée : ev, évènement qui déclenche la fonction
            Sortie : None 
            '''
            global best_k
            if best_k == 0:
                best_k = 5
            document["texte_profils"].html = ""
            characteristics = [{'Courage': 9, 'Ambition': 2, 'Intelligence': 8, 'Good': 9},
                                {'Courage': 6, 'Ambition': 7, 'Intelligence': 9, 'Good': 7},
                                {'Courage': 3, 'Ambition': 8, 'Intelligence': 6, 'Good': 3},
                                {'Courage': 2, 'Ambition': 3, 'Intelligence': 7, 'Good': 8},
                                {'Courage': 3, 'Ambition': 4, 'Intelligence': 8, 'Good': 8}]
            
            #programme plus proche voisin
            for profile in characteristics:
                profile_distance = distance_addition(indexed_characters_tab, profile)
                result = sorted(profile_distance, key=lambda x: x['Distance'])
                house_result = best_house(result[:best_k])
                #affichage
                document["texte_profils"].html += (f"La meilleure maison pour le personnage dont le profil est de {profile['Courage']} de courage,"
                      f" {profile['Ambition']} d'ambition, {profile['Intelligence']} d'intelligence "
                      f"et de {profile['Good']} de bonté est : {house_result}<br>"
                      f"En effet, il a pour voisins :<br>")
                for j in range(best_k):
                    document["texte_profils"].html += f"- {result[j]['Name']} de la maison {result[j]['House']}<br>"
                document["texte_profils"].html += "<br>"
        document["Profils demandés"].bind("click", profils_demandes)
        progression_question = 1
        def buttone(ev):
            '''
            Fait des trucs
            '''
            global progression_question
            global DICO_QUESTION
            
            if progression_question == 1:
                document["Reponse1"].textContent = DICO_QUESTION[progression_question]["Reponses"][0]
                document["Reponse2"].textContent = DICO_QUESTION[progression_question]["Reponses"][1]
                document["Reponse3"].textContent = DICO_QUESTION[progression_question]["Reponses"][2]
                document["image"].remove()
                question = DICO_QUESTION[progression_question]["Question"]
                document["Peur de respirer"].html = question
                document["display"] <= html.IMG(src='tt.jpg', width=300, height=400)
            elif progression_question == 2:
                document["Reponse1"].textContent = DICO_QUESTION[progression_question]["Reponses"][0]
                document["Reponse2"].textContent = DICO_QUESTION[progression_question]["Reponses"][1]
                document["Reponse3"].textContent = DICO_QUESTION[progression_question]["Reponses"][2]
                document["display"].clear()
                question = DICO_QUESTION[progression_question]["Question"]
                document["Peur de respirer"].html = question
                document["display"] <= html.IMG(src='gf.jpg', width=300, height=400)
            elif progression_question == 3:
                document["Reponse1"].textContent = DICO_QUESTION[progression_question]["Reponses"][0]
                document["Reponse2"].textContent = DICO_QUESTION[progression_question]["Reponses"][1]
                document["Reponse3"].textContent = DICO_QUESTION[progression_question]["Reponses"][2]
                document["display"].clear()
                question = DICO_QUESTION[progression_question]["Question"]
                document["Peur de respirer"].html = question
                document["display"] <= html.IMG(src='gf.jpg', width=300, height=400)

            
            document["display"] <= html.AUDIO(src='Gryffondor!-1.mp3', autoplay=True, volume="0.1")
            progression_question += 1
            
            
        document["Reponse1"].bind("click", buttone)
        document["Reponse2"].bind("click", buttone)
        document["Reponse3"].bind("click", buttone)
        def profil_personnalise(ev):
            '''
            Fait le résultat avec un profil personnalisé
            Entrée : ev, évènement qui déclenche la fonction
            Sortie : None
            '''
            global best_k
            if best_k == 0:
                best_k = 5
            #choix des caractéristiques personnalisées
            courage_choice = int(input("Saisissez une valeur de courage : "))
            ambition_choice = int(input("Saisissez une valeur d'ambition : "))
            intelligence_choice = int(input("Saisissez une valeur d'intelligence : "))
            good_choice = int(input("Saisissez une valeur de bonté : "))

            chosen_characteristics = {'Courage': courage_choice, 'Ambition': ambition_choice,
                                      'Intelligence': intelligence_choice, 'Good': good_choice}

            #application de l'algorithme pour les valeurs personnalisées
            custom_distance = distance_addition(indexed_characters_tab, chosen_characteristics)
            custom_result = sorted(custom_distance, key=lambda x: x['Distance'])
            custom_house_result = best_house(custom_result[:best_k])
            document["texte_profil_personnalisé"].html = (f"La meilleur maison pour le personnage dont le profil est de {chosen_characteristics['Courage']} de courage,"
                  f" {chosen_characteristics['Ambition']} d'ambition, {chosen_characteristics['Intelligence']} d'intelligence "
                  f"et de {chosen_characteristics['Good']} de bonté est : {custom_house_result}"
                  f"<br>En effet, il a pour voisins :<br>")
            for i in range(best_k):
                document["texte_profil_personnalisé"].html += f"- {custom_result[i]['Name']} de la maison {custom_result[i]['House']}<br>"
        document["Profil personnalisé"].bind("click", profil_personnalise)
    </script>

    <main>
        <article>
            <img src="Logo.png">
            <h3 id="Peur de respirer">As tu peur de respirer ?</h3>
            <br>
            <button class="glow-on-hover" id="Reponse1">Non je ne mange pas de ce pain la</button>
            <br>
            <button class="glow-on-hover" id="Reponse2">Jaaj</button>
            <br>
            <button class="glow-on-hover" id="Reponse3">Jauje</button>
            <p id="display"><img src='Dumbledore.gif' id="image" height="400px" width="300"></p>
            <button class="glow-on-hover" type="button" id="Profils demandés">Afficher résultats demandés</button>
            <p id="texte_profils">Affichage des profils demandés : </p>

            <button class="glow-on-hover" type="button" id="Profil personnalisé">Afficher profil personnalisé</button>
            <p id="texte_profil_personnalisé">Profil personnalisé : </p>
            <button class="glow-on-hover" type="button" id="Validation croisée">Oui, je déteste les frites</button>
        </article>
    </main>

    <footer>
        <p>© Copyright 2024 par le groupe Choixpeau. Tous droits réservés.</p>
    </footer>
</body>
</html>

